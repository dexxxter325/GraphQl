package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43
/*логика для выполнения запросов и мутаций*/
import (
	"GRAPHQL/graph/model"
	"context"
	"fmt"
)

// AddCar is the resolver for the addCar field.
func (r *mutationResolver) AddCar(ctx context.Context, input model.CarInput) (*model.Car, error) {
	var car model.Car
	createQuery := `INSERT INTO cars (brand, model, year, price, mileage, description)
											VALUES ($1, $2, $3, $4, $5, $6)
											RETURNING id, brand, model, year, price, mileage, description`
	query := r.DB.QueryRow(context.Background(), createQuery, input.Brand, input.Model, input.Year, input.Price, input.Mileage, input.Description)
	if err := query.Scan(&car.ID, &car.Brand, &car.Model, &car.Year, &car.Price, &car.Mileage, &car.Description); err != nil {
		return &car, fmt.Errorf("scan failed in create:%s", err)
	}
	return &car, nil
}

// UpdateCar is the resolver for the updateCar field.
func (r *mutationResolver) UpdateCar(ctx context.Context, id string, input model.CarInput) (*model.Car, error) {
	var car model.Car
	updateQuery := `UPDATE cars SET brand=$1,model=$2,year=$3,price=$4,mileage=$5,description=$6 where id=$7 RETURNING id, brand, model, year, price, mileage, description`
	query := r.DB.QueryRow(context.Background(), updateQuery, input.Brand, input.Model, input.Year, input.Price, input.Mileage, input.Description, id)
	if err := query.Scan(&car.ID, &car.Brand, &car.Model, &car.Year, &car.Price, &car.Mileage, &car.Description); err != nil {
		return &car, fmt.Errorf("scan failed in update")
	}
	return &car, nil
}

// DeleteCar is the resolver for the deleteCar field.
func (r *mutationResolver) DeleteCar(ctx context.Context, id string) (*bool, error) {
	fail := false
	success := true
	deleteQuery := `DELETE FROM cars where id=$1`
	res, err := r.DB.Exec(context.Background(), deleteQuery, id)
	if err != nil {
		return nil, fmt.Errorf("exec failed in delete:%s", err)
	}
	if res.RowsAffected() < 0 {
		return &fail, fmt.Errorf("this object already deleted or doesn't exist")
	}
	return &success, nil
}

// GetAllCars is the resolver for the getAllCars field.
func (r *queryResolver) GetAllCars(ctx context.Context) ([]*model.Car, error) {
	var cars []*model.Car
	getQuery := `SELECT * FROM cars ORDER BY id ASC;`
	query, err := r.DB.Query(context.Background(), getQuery)
	if err != nil {
		return nil, fmt.Errorf("failed query in getall:%s", err)
	}
	defer query.Close()
	for query.Next() { //читает каждую строку из результата sql query ,чтобы затем добавить в срез
		var car model.Car
		if err := query.Scan(&car.ID, &car.Brand, &car.Model, &car.Year, &car.Price, &car.Mileage, &car.Description); err != nil {
			return nil, fmt.Errorf("scan failed in getall:%s", err)
		}
		cars = append(cars, &car) //с каждой успешно прочитанной строкой,добавляем эл-т в срез
	}
	return cars, nil
}

// GetCarByID is the resolver for the getCarById field.
func (r *queryResolver) GetCarByID(ctx context.Context, id string) (*model.Car, error) {
	var car model.Car
	getByIdQuery := `SELECT * FROM cars where id=$1`
	query := r.DB.QueryRow(context.Background(), getByIdQuery, id)
	if err := query.Scan(&car.ID, &car.Brand, &car.Model, &car.Year, &car.Price, &car.Mileage, &car.Description); err != nil {
		return nil, fmt.Errorf("failed scan in getbyid:%s", err)
	}
	return &car, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
